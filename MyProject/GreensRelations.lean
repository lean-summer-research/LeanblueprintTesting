import Mathlib

/-!
# Green's preorders and equivalence relations on monoids

This file defines Greenâ€™s preorders and the corresponding equivalence relations on
a monoid `M`.  For elements `x` and `y` of `M` we write:

* `x â‰¤ð“¡ y` if `x` belongs to the principal right ideal generated by `y`, i.e.
  there exists `z : M` with `y * z = x`.
* `x â‰¤ð“› y` if `x` belongs to the principal left ideal generated by `y`, i.e.
  there exists `z : M` with `z * y = x`.
* `x â‰¤ð“™ y` if `x` belongs to the twoâ€‘sided ideal generated by `y`, i.e. there
  exist `u v : M` with `u * y * v = x`.
* `x â‰¤ð“— y` if both `x â‰¤ð“¡ y` and `x â‰¤ð“› y` hold.

By taking the symmetric closure of each preorder we obtain equivalence relations,
denoted `x ð“¡ y`, `x ð“› y`, `x ð“™ y` and `x ð“— y` respectively.  We also define the
`ð““` relation (not used yet) as the join of the right and left equivalences.

The main results in this file establish reflexivity and transitivity of the
preorders, construct the associated equivalence relations, and provide basic
lemmas for working with them.
-/

/-! ## Preorders -/

section Preorders

variable {M : Type*} [Monoid M]

/-- The **right preorder**: `RRel x y` holds if there exists `z` with `y * z = x`.
This means that `x` lies in the principal right ideal generated by `y`. -/
def RRel (x y : M) : Prop := âˆƒ z, y * z = x

/-- The **left preorder**: `LRel x y` holds if there exists `z` with `z * y = x`.
This means that `x` lies in the principal left ideal generated by `y`. -/
def LRel (x y : M) : Prop := âˆƒ z, z * y = x

/-- The **J preorder**: `JRel x y` holds if there exist `u v` with `u * y * v = x`.
This means that `x` lies in the twoâ€‘sided ideal generated by `y`. -/
def JRel (x y : M) : Prop := âˆƒ u v, u * y * v = x

/-- The **H preorder**: `HRel x y` holds if `x â‰¤ð“¡ y` and `x â‰¤ð“› y`. -/
def HRel (x y : M) : Prop := RRel x y âˆ§ LRel x y

/-- Notation for Greenâ€™s preorders. -/
notation:50 x " â‰¤ð“¡ " y:50 => RRel x y
notation:50 x " â‰¤ð“› " y:50 => LRel x y
notation:50 x " â‰¤ð“™ " y:50 => JRel x y
notation:50 x " â‰¤ð“— " y:50 => HRel x y

/-- Reflexivity of the right preorder. -/
@[simp] lemma RRel.refl (x : M) : x â‰¤ð“¡ x := by
  refine âŸ¨1, ?_âŸ©
  simp

/-- Reflexivity of the left preorder. -/
@[simp] lemma LRel.refl (x : M) : x â‰¤ð“› x := by
  refine âŸ¨1, ?_âŸ©
  simp

/-- Reflexivity of the J preorder. -/
@[simp] lemma JRel.refl (x : M) : x â‰¤ð“™ x := by
  refine âŸ¨1, 1, ?_âŸ©
  simp

/-- Reflexivity of the H preorder. -/
@[simp] lemma HRel.refl (x : M) : x â‰¤ð“— x := by
  exact âŸ¨RRel.refl x, LRel.refl xâŸ©

/-- Transitivity of the right preorder. -/
lemma RRel.trans {x y z : M} (hxy : x â‰¤ð“¡ y) (hyz : y â‰¤ð“¡ z) : x â‰¤ð“¡ z := by
  rcases hxy with âŸ¨v, hvâŸ©
  rcases hyz with âŸ¨u, huâŸ©
  refine âŸ¨u * v, ?_âŸ©
  rw [â† mul_assoc]
  rw [hu, hv]

/-- Transitivity of the left preorder. -/
lemma LRel.trans {x y z : M} (hxy : x â‰¤ð“› y) (hyz : y â‰¤ð“› z) : x â‰¤ð“› z := by
  rcases hxy with âŸ¨u, huâŸ©
  rcases hyz with âŸ¨v, hvâŸ©
  refine âŸ¨u * v, ?_âŸ©
  simp [hu, hv, mul_assoc]

/-- Transitivity of the J preorder. -/
lemma JRel.trans {x y z : M} (hxy : x â‰¤ð“™ y) (hyz : y â‰¤ð“™ z) : x â‰¤ð“™ z := by
  rcases hxy with âŸ¨uâ‚, vâ‚, hxâŸ©
  rcases hyz with âŸ¨uâ‚‚, vâ‚‚, hyâŸ©
  refine âŸ¨uâ‚ * uâ‚‚, vâ‚‚ * vâ‚, ?_âŸ©
  calc
    uâ‚ * uâ‚‚ * z * (vâ‚‚ * vâ‚)
    = uâ‚ * (uâ‚‚ * z * vâ‚‚) * vâ‚ := by simp [mul_assoc]
    _ = uâ‚ * y * vâ‚ := by simp [hy]
    _ = x := by simp [hx]

/-- Transitivity of the H preorder. -/
lemma HRel.trans {x y z : M} (hxy : x â‰¤ð“— y) (hyz : y â‰¤ð“— z) : x â‰¤ð“— z := by
  rcases hxy with âŸ¨hRâ‚, hLâ‚âŸ©
  rcases hyz with âŸ¨hRâ‚‚, hLâ‚‚âŸ©
  exact âŸ¨RRel.trans hRâ‚ hRâ‚‚, LRel.trans hLâ‚ hLâ‚‚âŸ©

/-- The right preorder is a preorder. -/
instance RRel.isPreorder : IsPreorder M RRel where
  refl := RRel.refl
  trans := by
    intro x y z hxy hyz
    exact RRel.trans hxy hyz

/-- The left preorder is a preorder. -/
instance LRel.isPreorder : IsPreorder M LRel where
  refl := LRel.refl
  trans := by
    intro x y z hxy hyz
    exact LRel.trans hxy hyz

/-- The J preorder is a preorder. -/
instance JRel.isPreorder : IsPreorder M JRel where
  refl := JRel.refl
  trans := by
    intro x y z hxy hyz
    exact JRel.trans hxy hyz

/-- The H preorder is a preorder. -/
instance HRel.isPreorder : IsPreorder M HRel where
  refl := HRel.refl
  trans := by
    intro x y z hxy hyz
    exact HRel.trans hxy hyz

end Preorders

/-! ## Equivalences from preorders -/

section EquivOfLE

variable {Î± : Type*} (p : Î± â†’ Î± â†’ Prop) [hp : IsPreorder Î± p]

/-- From any preorder `p` we can form an equivalence relation:
`EquivOfLE p x y` holds if both `p x y` and `p y x`. -/
@[simp] def EquivOfLE (x y : Î±) : Prop :=
  p x y âˆ§ p y x

/-- `EquivOfLE p` is an equivalence relation when `p` is a preorder. -/
instance EquivOfLE.isEquivalence : Equivalence (EquivOfLE p) where
  refl := by
    intro x
    exact âŸ¨hp.refl x, hp.refl xâŸ©
  symm := by
    intro x y hxy
    exact âŸ¨hxy.2, hxy.1âŸ©
  trans := by
    intro x y z hxy hyz
    constructor
    Â· exact hp.trans x y z hxy.1 hyz.1
    Â· exact hp.trans z y x hyz.2 hxy.2

end EquivOfLE

section Equivalences

variable {M : Type*} [Monoid M]

/-- The **right equivalence**: `REquiv x y` holds if `x â‰¤ð“¡ y` and `y â‰¤ð“¡ x`. -/
def REquiv (x y : M) : Prop := EquivOfLE RRel x y

/-- The **left equivalence**: `LEquiv x y` holds if `x â‰¤ð“› y` and `y â‰¤ð“› x`. -/
def LEquiv (x y : M) : Prop := EquivOfLE LRel x y

/-- The **J equivalence**: `JEquiv x y` holds if `x â‰¤ð“™ y` and `y â‰¤ð“™ x`. -/
def JEquiv (x y : M) : Prop := EquivOfLE JRel x y

/-- The **H equivalence**: `HEquiv x y` holds if `x â‰¤ð“— y` and `y â‰¤ð“— x`. -/
def HEquiv (x y : M) : Prop := EquivOfLE HRel x y

/-- Notation for the Green equivalences using calligraphic letters. -/
notation:50 x " ð“¡ " y:50 => REquiv x y
notation:50 x " ð“› " y:50 => LEquiv x y
notation:50 x " ð“™ " y:50 => JEquiv x y
notation:50 x " ð“— " y:50 => HEquiv x y

/-- The right equivalence is an equivalence relation. -/
instance REquiv.isEquivalence : Equivalence (fun x y : M => x ð“¡ y) := by
  exact EquivOfLE.isEquivalence RRel

/-- The left equivalence is an equivalence relation. -/
instance LEquiv.isEquivalence : Equivalence (fun x y : M => x ð“› y) := by
  exact EquivOfLE.isEquivalence LRel

/-- The J equivalence is an equivalence relation. -/
instance JEquiv.isEquivalence : Equivalence (fun x y : M => x ð“™ y) := by
  exact EquivOfLE.isEquivalence JRel

/-- The H equivalence is an equivalence relation. -/
instance HEquiv.isEquivalence : Equivalence (fun x y : M => x ð“— y) := by
  exact EquivOfLE.isEquivalence HRel

/-- Reflexivity under right equivalence. -/
@[simp] lemma REquiv.refl (x : M) : x ð“¡ x := by
  exact (REquiv.isEquivalence (M := M)).refl x

/-- Symmetry under right equivalence. -/
@[symm] lemma REquiv.symm {x y : M} (h : x ð“¡ y) : y ð“¡ x := by
  exact (REquiv.isEquivalence (M := M)).symm h

/-- Transitivity under right equivalence. -/
lemma REquiv.trans {x y z : M} (hxy : x ð“¡ y) (hyz : y ð“¡ z) : x ð“¡ z := by
  exact (REquiv.isEquivalence (M := M)).trans hxy hyz

-- Similar lemmas for L, J and H equivalences

@[simp] lemma LEquiv.refl (x : M) : x ð“› x := by
  exact (LEquiv.isEquivalence (M := M)).refl x

@[symm] lemma LEquiv.symm {x y : M} (h : x ð“› y) : y ð“› x := by
  exact (LEquiv.isEquivalence (M := M)).symm h

lemma LEquiv.trans {x y z : M} (hxy : x ð“› y) (hyz : y ð“› z) : x ð“› z := by
  exact (LEquiv.isEquivalence (M := M)).trans hxy hyz

@[simp] lemma JEquiv.refl (x : M) : x ð“™ x := by
  exact (JEquiv.isEquivalence (M := M)).refl x

@[symm] lemma JEquiv.symm {x y : M} (h : x ð“™ y) : y ð“™ x := by
  exact (JEquiv.isEquivalence (M := M)).symm h

lemma JEquiv.trans {x y z : M} (hxy : x ð“™ y) (hyz : y ð“™ z) : x ð“™ z := by
  exact (JEquiv.isEquivalence (M := M)).trans hxy hyz

@[simp] lemma HEquiv.refl (x : M) : x ð“— x := by
  exact (HEquiv.isEquivalence (M := M)).refl x

@[symm] lemma HEquiv.symm {x y : M} (h : x ð“— y) : y ð“— x := by
  exact (HEquiv.isEquivalence (M := M)).symm h

lemma HEquiv.trans {x y z : M} (hxy : x ð“— y) (hyz : y ð“— z) : x ð“— z := by
  exact (HEquiv.isEquivalence (M := M)).trans hxy hyz

end Equivalences

/-! ## Conversion Lemmas-/

section BasicLemmas

variable {M : Type*} [Monoid M] {x y z u v e : M}

/-- Converting two right-preorder hypotheses into a right equivalence. -/
@[simp] lemma REquiv.of_le (hxy : x â‰¤ð“¡ y) (hyx : y â‰¤ð“¡ x) : x ð“¡ y := âŸ¨hxy, hyxâŸ©

/-- Similar lemma for the left preorder. -/
@[simp] lemma LEquiv.of_le (hxy : x â‰¤ð“› y) (hyx : y â‰¤ð“› x) : x ð“› y := âŸ¨hxy, hyxâŸ©

/-- Similar lemma for the J preorder. -/
@[simp] lemma JEquiv.of_le (hxy : x â‰¤ð“™ y) (hyx : y â‰¤ð“™ x) : x ð“™ y := âŸ¨hxy, hyxâŸ©

/-- Similar lemma for the H preorder. -/
@[simp] lemma HEquiv.of_le (hxy : x â‰¤ð“— y) (hyx : y â‰¤ð“— x) : x ð“— y := âŸ¨hxy, hyxâŸ©

/-- The right preorder embeds into the J preorder. -/
@[simp] lemma RRel.to_JRel (h : x â‰¤ð“¡ y) : x â‰¤ð“™ y := by
  rcases h with âŸ¨t, htâŸ©
  refine âŸ¨1, t, ?_âŸ©
  simpa using ht

/-- The left preorder embeds into the J preorder. -/
@[simp] lemma LRel.to_JRel (h : x â‰¤ð“› y) : x â‰¤ð“™ y := by
  rcases h with âŸ¨t, htâŸ©
  refine âŸ¨t, 1, ?_âŸ©
  simpa using ht

/-- From an R-equivalence we can deduce the right preorder. -/
@[simp] theorem REquiv.le (h : x ð“¡ y) : x â‰¤ð“¡ y := h.1

/-- From an L-equivalence we can deduce the left preorder. -/
@[simp] theorem LEquiv.le (h : x ð“› y) : x â‰¤ð“› y := h.1

/-- From a J-equivalence we can deduce the J preorder. -/
@[simp] theorem JEquiv.le (h : x ð“™ y) : x â‰¤ð“™ y := h.1

/-- From an H-equivalence we can deduce the H preorder. -/
@[simp] theorem HEquiv.le (h : x ð“— y) : x â‰¤ð“— y := h.1

/-- From an R-equivalence we obtain the reversed right preorder. -/
@[simp] theorem REquiv.ge (h : x ð“¡ y) : y â‰¤ð“¡ x := h.2

@[simp] theorem LEquiv.ge (h : x ð“› y) : y â‰¤ð“› x := h.2
@[simp] theorem JEquiv.ge (h : x ð“™ y) : y â‰¤ð“™ x := h.2
@[simp] theorem HEquiv.ge (h : x ð“— y) : y â‰¤ð“— x := h.2

/-- R-equivalence implies J-equivalence. -/
@[simp] theorem REquiv.to_JEquiv (h : x ð“¡ y) : x ð“™ y := by simp_all [REquiv]

/-- L-equivalence implies J-equivalence. -/
@[simp] theorem LEquiv.to_JEquiv (h : x ð“› y) : x ð“™ y := by simp_all [LEquiv]

/-- H-preorder implies R-preorder -/
@[simp] lemma HRel.to_RRel (h : x â‰¤ð“— y) : x â‰¤ð“¡ y := by simp_all [HRel]

/-- H-preorder implies L-preorder -/
@[simp] lemma HRel.to_LRel (h : x â‰¤ð“— y) : x â‰¤ð“› y := by simp_all [HRel]

/-- H-preorder implies J-preorder -/
@[simp] lemma HRel.to_JRel (h : x â‰¤ð“— y) : x â‰¤ð“™ y := by simp_all [HRel]

@[simp] lemma HEquiv.to_REquiv (h : x ð“— y) : x ð“¡ y := by simp_all [HEquiv, REquiv]

/-- H-equivalence implies L-equivalence. -/
@[simp] lemma HEquiv.to_LEquiv (h : x ð“— y) : x ð“› y := by simp_all [LEquiv]

/-! ### Basic Idempotent Properties -/

/-- Characterisation of the right preorder using an idempotent. -/
lemma RRel.idempotent_iff (h : IsIdempotentElem e) :
    x â‰¤ð“¡ e â†” e * x = x := by
  constructor
  Â· rintro âŸ¨t, htâŸ©
    rw [â† ht, â† mul_assoc]
    rw [h]
  Â· intro hx
    refine âŸ¨x, ?_âŸ©
    exact hx

/-- Characterisation of the left preorder using an idempotent. -/
lemma LRel.idempotent_iff (h : IsIdempotentElem e) :
    x â‰¤ð“› e â†” x * e = x := by
  constructor
  Â· rintro âŸ¨t, htâŸ©
    rw [â† ht, mul_assoc]
    rw [h]
  Â· intro hx
    refine âŸ¨x, ?_âŸ©
    exact hx

/-- ### H-Equivalence charactarization -/
theorem HEquiv.iff : x ð“— y â†” x ð“¡ y âˆ§ x ð“› y := by
  simp [HEquiv, REquiv, LEquiv, HRel]
  aesop

/-! ### Cancelation lemmas -/

/-- `x * y` is always `â‰¤ð“¡ x` -/
@[simp] lemma RRel.mul_right_self (x y : M) : x * y â‰¤ð“¡ x := by use y

/-- `y * x` is always `â‰¤ð“› x` -/
@[simp] lemma LRel.mul_left_self : y * x â‰¤ð“› x := by use y

/-- `u * x * v` is always `â‰¤ð“™ x` -/
@[simp] lemma JRel.mul_sandwich_self : u * x * v â‰¤ð“™ x := by use u, v

/-- if `x` is J-below `y * z`, then it is J-below `z` -/
lemma JRel.left_cancel {x y z : M} (h : x â‰¤ð“™ y * z) : x â‰¤ð“™ z := by
  obtain âŸ¨u, v, huvâŸ© := h
  use u * y, v
  simp_all [â† mul_assoc]

/-- if `x` is J-below `y * z`, then it is J-below `y` -/
lemma JRel.right_cancel {x y z : M} (h : x â‰¤ð“™ y * z) : x â‰¤ð“™ y := by
  obtain âŸ¨u, v, huvâŸ© := h
  use u , z * v
  simp_all [â† mul_assoc]

/-- if `x` is R-below `y * z`, then it is R-below `y` -/
lemma RRel.right_cancel {x y z : M} (h : x â‰¤ð“¡ y * z) : x â‰¤ð“¡ y := by
  rcases h with âŸ¨u, huâŸ©
  use z * u
  simp_all [â† mul_assoc]

/-- if `x` is L-below `y * z`, then it is L-below `z` -/
lemma LRel.left_cancel {x y z : M} (h : x â‰¤ð“› y * z) : x â‰¤ð“› z := by
  rcases h with âŸ¨u, huvâŸ©
  use u * y
  simp_all [â† mul_assoc]

end BasicLemmas

/-!
### Statements about ð“¡ and ð“›
We prove that ð“¡ and ð“› are compatable with left/right multiplication, respectivly.
We also prove that ð“¡ and ð“› (and their preorders) commute under composition.
These lemmas are essential for proving that ð““ is an equivalence.
-/

section REquivLEquiv

open MulOpposite

variable {M : Type*} [Monoid M] {x y z : M}

/-- `â‰¤ð“¡` is compatable with left multiplication -/
@[simp] lemma RRel.mul_left_compat (z : M) (h : x â‰¤ð“¡ y) : z * x â‰¤ð“¡ z * y := by
  obtain âŸ¨u, huâŸ© := h
  use u
  simp [mul_assoc, hu]

/-- `â‰¤ð“›` is compatable with right multiplication -/
@[simp] lemma LRel.mul_right_compat (z : M) (h : x â‰¤ð“› y) : x * z â‰¤ð“› y * z := by
  obtain âŸ¨u, huâŸ© := h
  use u
  simp [â† mul_assoc, hu]

/-- `ð“¡` is compatable with left multiplication -/
@[simp] lemma REquiv.mul_left_compat (z : M) (h : x ð“¡ y) : z * x ð“¡ z * y := by simp_all [REquiv]

/-- `ð“›` is compatable with right multiplication -/
@[simp] lemma LEquiv.mul_right_compat (z : M) (h : x ð“› y) : x * z ð“› y * z := by simp_all [LEquiv]

-- Note: is this the same as the J relation?
lemma rLE_lLE_of_comm (hL : x â‰¤ð“› z) (hR : z â‰¤ð“¡ y) : âˆƒ u, x â‰¤ð“¡ u âˆ§ u â‰¤ð“› y := by
  rcases _ : hL with âŸ¨v, hvâŸ©
  rcases _ : hR with âŸ¨w, hwâŸ©
  use v * y
  simp [â† hv, hR]

-- Dual to above
lemma lLE_rLE_of_comm (hR : x â‰¤ð“¡ z) (hL : z â‰¤ð“› y) : âˆƒ u, x â‰¤ð“› u âˆ§ u â‰¤ð“¡ y := by
  rcases _ : hL with âŸ¨v, hvâŸ©
  rcases _ : hR with âŸ¨w, hwâŸ©
  use y * w
  simp [â† hw, hL]

/-- `â‰¤ð“¡` commutes with `â‰¤ð“›` under composition. -/
theorem rLE_lLE_comm (x y : M) : (âˆƒ z, x â‰¤ð“› z âˆ§ z â‰¤ð“¡ y) â†” âˆƒ z, x â‰¤ð“¡ z âˆ§ z â‰¤ð“› y := by
  constructor
  Â· rintro âŸ¨u, hL, hRâŸ©
    apply rLE_lLE_of_comm hL hR
  Â· rintro âŸ¨u, hL, hRâŸ©
    apply lLE_rLE_of_comm hL hR

/-- `ð“¡` commutes with `ð“›` under composition. -/
lemma rEquiv_lEquiv_of_comm (hL : x ð“› z) (hR : z ð“¡ y) : âˆƒ u, x ð“¡ u âˆ§ u ð“› y := by
  rcases _ : hL with âŸ¨hLâ‚, hLâ‚‚âŸ© -- the `_ : hL` syntax preserves the original hL
  rcases _ : hR with âŸ¨hRâ‚, hRâ‚‚âŸ©
  obtain âŸ¨t, htâŸ© := hLâ‚
  use t * y
  subst x
  constructor
  Â· simp [hR] -- proof `t * z ð“¡ t * y`
  Â· simp [LEquiv] --  proof `t * y ð“› y`
    obtain âŸ¨w, hwâŸ© := hRâ‚‚
    rw [â† hw, â† mul_assoc]
    simp [hLâ‚‚]

-- Dual of above
lemma lEquiv_rEquiv_of_comm (hR : x ð“¡ z) (hL : z ð“› y) : âˆƒ u, x ð“› u âˆ§ u ð“¡ y := by
  rcases _ : hL with âŸ¨hLâ‚, hLâ‚‚âŸ©
  rcases _ : hR with âŸ¨hRâ‚, hRâ‚‚âŸ©
  obtain âŸ¨t, htâŸ© := hRâ‚
  use y * t
  subst x
  constructor
  Â· simp [hL]
  Â· simp [REquiv]
    obtain âŸ¨w, hwâŸ© := hLâ‚‚
    rw [â† hw, mul_assoc]
    simp [hRâ‚‚]

/-- **Green's Commutativity**: R and L relations commute under composition -/
theorem rEquiv_lEquiv_comm: (âˆƒ z, x ð“› z âˆ§ z ð“¡ y) â†” âˆƒ z, x ð“¡ z âˆ§ z ð“› y := by
  constructor
  Â· rintro âŸ¨z, hL, hRâŸ©
    apply rEquiv_lEquiv_of_comm hL hR
  Â· rintro âŸ¨z, hL, hRâŸ©
    apply lEquiv_rEquiv_of_comm hL hR

end REquivLEquiv

/-! ### ð““ Relation -/

section DEquiv

variable {M : Type*} [Monoid M]

/-- The **D equivalence**: `DEquiv x y` holds if
there exists a `z` such that  `x ð“¡ z` and `z ð“› y`. -/
def DEquiv (x y : M) : Prop := âˆƒ z, x ð“¡ z âˆ§ z ð“› y

notation:50 x " ð““ " y:50 => DEquiv x y

/-- Alternate Def of `ð““`, equivalent by ð“¡-ð“› communitivity -/
theorem DEquiv.comm {x y : M} : (âˆƒ z, x ð“› z âˆ§ z ð“¡ y) â†” x ð““ y := by
  simp [DEquiv, rEquiv_lEquiv_comm]

open MulOpposite in

@[simp] lemma DEquiv.refl (x : M) : x ð““ x := by use x; simp_all

variable {x y z : M}

@[symm] lemma DEquiv.symm (h : x ð““ y) : y ð““ x := by
  simp_all [DEquiv]
  rw [â† rEquiv_lEquiv_comm]
  obtain âŸ¨z, âŸ¨hR, hLâŸ©âŸ© := h
  use z
  exact âŸ¨hL.symm, hR.symmâŸ©

/-- The ð““-relation is preserved by ð“›-equivalent elements on the right.
If `a ð““ b` and `b ð“› c`, then `a ð““ c`. -/
lemma DEquiv.closed_under_lEquiv (hD : x ð““ y) (hL : y ð“› z) : x ð““ z := by
  simp_all [DEquiv]
  obtain âŸ¨u, âŸ¨hR, hLâ‚‚âŸ©âŸ© := hD
  use u
  simp_all
  apply LEquiv.trans hLâ‚‚ hL

-- Dual to above
lemma DEquiv.closed_under_rEquiv (hD : x ð““ y) (hR : y ð“¡ z) : x ð““ z := by
  have hDâ‚ := hD.symm
  symm
  simp_all [DEquiv]
  obtain âŸ¨u, âŸ¨hRâ‚‚, hLâ‚‚âŸ©âŸ© := hDâ‚
  use u
  simp_all
  apply REquiv.trans hR.symm hRâ‚‚

/-- The ð““-relation is transitive. This is proved using closure under ð“¡ and ð“›. -/
lemma DEquiv.trans (hâ‚ : x ð““ y) (hâ‚‚ : y ð““ z) : x ð““ z := by
  obtain âŸ¨u, âŸ¨hy1, hy2âŸ©âŸ© := hâ‚‚
  have hd1 : x ð““ u := DEquiv.closed_under_rEquiv hâ‚ hy1
  apply DEquiv.closed_under_lEquiv hd1 hy2

/-- The ð““-relation is an equivalence relation on `M`. -/
instance DEquiv.isEquiv: Equivalence (fun a b : M => a ð““ b) where
  refl := DEquiv.refl
  symm := DEquiv.symm
  trans := DEquiv.trans

/-! ### Conversion Lemmas for DEquiv -/

@[simp] lemma REquiv.to_dEquiv (h : x ð“¡ y) : x ð““ y := by use y; simp_all
@[simp] lemma LEquiv.to_dEquiv (h : x ð“› y) : x ð““ y := by use x; simp_all

/-- Every ð““-related pair is ð“™-related.
Note that the reverse implication only holds in finite semigroups.
This will be proven later. -/
@[simp] theorem DEquiv.to_JEquiv (h : x ð““ y): x ð“™ y := by
  simp_all [DEquiv, JEquiv]
  rcases h with âŸ¨z, âŸ¨âŸ¨t, hRâ‚âŸ©, âŸ¨u, hRâ‚‚âŸ©âŸ© , âŸ¨âŸ¨v, hLâ‚âŸ©, âŸ¨w, hLâ‚‚âŸ©âŸ©âŸ©
  constructor
  Â· use v, t
    rw [â† hRâ‚, â† hLâ‚]
  Â· use w, u
    rw [â† hLâ‚‚, â† hRâ‚‚, â† mul_assoc]

end DEquiv

/-! ### Equivalence classes as Sets -/

section EquivalenceClasses

variable {M : Type*} [Monoid M] (x : M)

@[simp] def RClass : Set M := {y | y ð“¡ x}
@[simp] def LClass : Set M := {y | y ð“› x}
@[simp] def JClass : Set M := {y | y ð“™ x}
@[simp] def HClass : Set M := {y | y ð“— x}
@[simp] def DClass : Set M := {y | y ð““ x}

notation "âŸ¦" x "âŸ§ð“¡" => RClass x
notation "âŸ¦" x "âŸ§ð“›" => LClass x
notation "âŸ¦" x "âŸ§ð“™" => JClass x
notation "âŸ¦" x "âŸ§ð“—" => HClass x
notation "âŸ¦" x "âŸ§ð““" => DClass x

/-!
### Registration of Simp sets
This must be done in this file because lean does not allow you to register
and populate a simp set in the same file.
-/

register_simp_attr fromOpp
