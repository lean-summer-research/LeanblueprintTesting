import Mathlib

/-!
# Green's preorders and equivalence relations on monoids

This file defines Green’s preorders and the corresponding equivalence relations on
a monoid `M`.  For elements `x` and `y` of `M` we write:

* `x ≤𝓡 y` if `x` belongs to the principal right ideal generated by `y`, i.e.
  there exists `z : M` with `y * z = x`.
* `x ≤𝓛 y` if `x` belongs to the principal left ideal generated by `y`, i.e.
  there exists `z : M` with `z * y = x`.
* `x ≤𝓙 y` if `x` belongs to the two‑sided ideal generated by `y`, i.e. there
  exist `u v : M` with `u * y * v = x`.
* `x ≤𝓗 y` if both `x ≤𝓡 y` and `x ≤𝓛 y` hold.

By taking the symmetric closure of each preorder we obtain equivalence relations,
denoted `x 𝓡 y`, `x 𝓛 y`, `x 𝓙 y` and `x 𝓗 y` respectively.  We also define the
`𝓓` relation (not used yet) as the join of the right and left equivalences.

The main results in this file establish reflexivity and transitivity of the
preorders, construct the associated equivalence relations, and provide basic
lemmas for working with them.
-/

namespace Green

/-! ## Preorders -/

section Preorders

variable {M : Type*} [Monoid M]

/-- The **right preorder**: `RRel x y` holds if there exists `z` with `y * z = x`.
This means that `x` lies in the principal right ideal generated by `y`. -/
def RRel (x y : M) : Prop := ∃ z, y * z = x

/-- The **left preorder**: `LRel x y` holds if there exists `z` with `z * y = x`.
This means that `x` lies in the principal left ideal generated by `y`. -/
def LRel (x y : M) : Prop := ∃ z, z * y = x

/-- The **J preorder**: `JRel x y` holds if there exist `u v` with `u * y * v = x`.
This means that `x` lies in the two‑sided ideal generated by `y`. -/
def JRel (x y : M) : Prop := ∃ u v, u * y * v = x

/-- The **H preorder**: `HRel x y` holds if `x ≤𝓡 y` and `x ≤𝓛 y`. -/
def HRel (x y : M) : Prop := RRel x y ∧ LRel x y

/-- Notation for Green’s preorders. -/
notation:50 x " ≤𝓡 " y:50 => RRel x y
notation:50 x " ≤𝓛 " y:50 => LRel x y
notation:50 x " ≤𝓙 " y:50 => JRel x y
notation:50 x " ≤𝓗 " y:50 => HRel x y

/-- Reflexivity of the right preorder. -/
@[simp] lemma RRel.refl (x : M) : x ≤𝓡 x := by
  refine ⟨1, ?_⟩
  simp

/-- Reflexivity of the left preorder. -/
@[simp] lemma LRel.refl (x : M) : x ≤𝓛 x := by
  refine ⟨1, ?_⟩
  simp

/-- Reflexivity of the J preorder. -/
@[simp] lemma JRel.refl (x : M) : x ≤𝓙 x := by
  refine ⟨1, 1, ?_⟩
  simp

/-- Reflexivity of the H preorder. -/
@[simp] lemma HRel.refl (x : M) : x ≤𝓗 x := by
  exact ⟨RRel.refl x, LRel.refl x⟩

/-- Transitivity of the right preorder. -/
lemma RRel.trans {x y z : M} (hxy : x ≤𝓡 y) (hyz : y ≤𝓡 z) : x ≤𝓡 z := by
  rcases hxy with ⟨v, hv⟩
  rcases hyz with ⟨u, hu⟩
  refine ⟨u * v, ?_⟩
  rw [← mul_assoc]
  rw [hu, hv]

/-- Transitivity of the left preorder. -/
lemma LRel.trans {x y z : M} (hxy : x ≤𝓛 y) (hyz : y ≤𝓛 z) : x ≤𝓛 z := by
  rcases hxy with ⟨u, hu⟩
  rcases hyz with ⟨v, hv⟩
  refine ⟨u * v, ?_⟩
  simp [hu, hv, mul_assoc]

/-- Transitivity of the J preorder. -/
lemma JRel.trans {x y z : M} (hxy : x ≤𝓙 y) (hyz : y ≤𝓙 z) : x ≤𝓙 z := by
  rcases hxy with ⟨u₁, v₁, hx⟩
  rcases hyz with ⟨u₂, v₂, hy⟩
  refine ⟨u₁ * u₂, v₂ * v₁, ?_⟩
  calc
    u₁ * u₂ * z * (v₂ * v₁)
    = u₁ * (u₂ * z * v₂) * v₁ := by simp [mul_assoc]
    _ = u₁ * y * v₁ := by simp [hy]
    _ = x := by simp [hx]

/-- Transitivity of the H preorder. -/
lemma HRel.trans {x y z : M} (hxy : x ≤𝓗 y) (hyz : y ≤𝓗 z) : x ≤𝓗 z := by
  rcases hxy with ⟨hR₁, hL₁⟩
  rcases hyz with ⟨hR₂, hL₂⟩
  exact ⟨RRel.trans hR₁ hR₂, LRel.trans hL₁ hL₂⟩

/-- The right preorder is a preorder. -/
instance RRel.isPreorder : IsPreorder M RRel where
  refl := RRel.refl
  trans := by
    intro x y z hxy hyz
    exact RRel.trans hxy hyz

/-- The left preorder is a preorder. -/
instance LRel.isPreorder : IsPreorder M LRel where
  refl := LRel.refl
  trans := by
    intro x y z hxy hyz
    exact LRel.trans hxy hyz

/-- The J preorder is a preorder. -/
instance JRel.isPreorder : IsPreorder M JRel where
  refl := JRel.refl
  trans := by
    intro x y z hxy hyz
    exact JRel.trans hxy hyz

/-- The H preorder is a preorder. -/
instance HRel.isPreorder : IsPreorder M HRel where
  refl := HRel.refl
  trans := by
    intro x y z hxy hyz
    exact HRel.trans hxy hyz

end Preorders

/-! ## Equivalences from preorders -/

section EquivOfLE

variable {α : Type*} (p : α → α → Prop) [hp : IsPreorder α p]

/-- From any preorder `p` we can form an equivalence relation:
`EquivOfLE p x y` holds if both `p x y` and `p y x`. -/
@[simp] def EquivOfLE (x y : α) : Prop :=
  p x y ∧ p y x

/-- `EquivOfLE p` is an equivalence relation when `p` is a preorder. -/
instance EquivOfLE.isEquivalence : Equivalence (EquivOfLE p) where
  refl := by
    intro x
    exact ⟨hp.refl x, hp.refl x⟩
  symm := by
    intro x y hxy
    exact ⟨hxy.2, hxy.1⟩
  trans := by
    intro x y z hxy hyz
    constructor
    · exact hp.trans x y z hxy.1 hyz.1
    · exact hp.trans z y x hyz.2 hxy.2

end EquivOfLE

section Equivalences

variable {M : Type*} [Monoid M]

/-- The **right equivalence**: `REquiv x y` holds if `x ≤𝓡 y` and `y ≤𝓡 x`. -/
def REquiv (x y : M) : Prop := EquivOfLE RRel x y

/-- The **left equivalence**: `LEquiv x y` holds if `x ≤𝓛 y` and `y ≤𝓛 x`. -/
def LEquiv (x y : M) : Prop := EquivOfLE LRel x y

/-- The **J equivalence**: `JEquiv x y` holds if `x ≤𝓙 y` and `y ≤𝓙 x`. -/
def JEquiv (x y : M) : Prop := EquivOfLE JRel x y

/-- The **H equivalence**: `HEquiv x y` holds if `x ≤𝓗 y` and `y ≤𝓗 x`. -/
def HEquiv (x y : M) : Prop := EquivOfLE HRel x y

/-- Notation for the Green equivalences using calligraphic letters. -/
notation:50 x " 𝓡 " y:50 => REquiv x y
notation:50 x " 𝓛 " y:50 => LEquiv x y
notation:50 x " 𝓙 " y:50 => JEquiv x y
notation:50 x " 𝓗 " y:50 => HEquiv x y

/-- The right equivalence is an equivalence relation. -/
instance REquiv.isEquivalence : Equivalence (fun x y : M => x 𝓡 y) := by
  exact EquivOfLE.isEquivalence RRel

/-- The left equivalence is an equivalence relation. -/
instance LEquiv.isEquivalence : Equivalence (fun x y : M => x 𝓛 y) := by
  exact EquivOfLE.isEquivalence LRel

/-- The J equivalence is an equivalence relation. -/
instance JEquiv.isEquivalence : Equivalence (fun x y : M => x 𝓙 y) := by
  exact EquivOfLE.isEquivalence JRel

/-- The H equivalence is an equivalence relation. -/
instance HEquiv.isEquivalence : Equivalence (fun x y : M => x 𝓗 y) := by
  exact EquivOfLE.isEquivalence HRel

/-- Reflexivity under right equivalence. -/
@[simp] lemma REquiv.refl (x : M) : x 𝓡 x := by
  exact (REquiv.isEquivalence (M := M)).refl x

/-- Symmetry under right equivalence. -/
@[symm] lemma REquiv.symm {x y : M} (h : x 𝓡 y) : y 𝓡 x := by
  exact (REquiv.isEquivalence (M := M)).symm h

/-- Transitivity under right equivalence. -/
lemma REquiv.trans {x y z : M} (hxy : x 𝓡 y) (hyz : y 𝓡 z) : x 𝓡 z := by
  exact (REquiv.isEquivalence (M := M)).trans hxy hyz

-- Similar lemmas for L, J and H equivalences

@[simp] lemma LEquiv.refl (x : M) : x 𝓛 x := by
  exact (LEquiv.isEquivalence (M := M)).refl x

@[symm] lemma LEquiv.symm {x y : M} (h : x 𝓛 y) : y 𝓛 x := by
  exact (LEquiv.isEquivalence (M := M)).symm h

lemma LEquiv.trans {x y z : M} (hxy : x 𝓛 y) (hyz : y 𝓛 z) : x 𝓛 z := by
  exact (LEquiv.isEquivalence (M := M)).trans hxy hyz

@[simp] lemma JEquiv.refl (x : M) : x 𝓙 x := by
  exact (JEquiv.isEquivalence (M := M)).refl x

@[symm] lemma JEquiv.symm {x y : M} (h : x 𝓙 y) : y 𝓙 x := by
  exact (JEquiv.isEquivalence (M := M)).symm h

lemma JEquiv.trans {x y z : M} (hxy : x 𝓙 y) (hyz : y 𝓙 z) : x 𝓙 z := by
  exact (JEquiv.isEquivalence (M := M)).trans hxy hyz

@[simp] lemma HEquiv.refl (x : M) : x 𝓗 x := by
  exact (HEquiv.isEquivalence (M := M)).refl x

@[symm] lemma HEquiv.symm {x y : M} (h : x 𝓗 y) : y 𝓗 x := by
  exact (HEquiv.isEquivalence (M := M)).symm h

lemma HEquiv.trans {x y z : M} (hxy : x 𝓗 y) (hyz : y 𝓗 z) : x 𝓗 z := by
  exact (HEquiv.isEquivalence (M := M)).trans hxy hyz

end Equivalences

/-! ## Conversion Lemmas-/

section BasicLemmas

variable {M : Type*} [Monoid M] {x y z u v e : M}

/-- Converting two right-preorder hypotheses into a right equivalence. -/
@[simp] lemma REquiv.of_le (hxy : x ≤𝓡 y) (hyx : y ≤𝓡 x) : x 𝓡 y := ⟨hxy, hyx⟩

/-- Similar lemma for the left preorder. -/
@[simp] lemma LEquiv.of_le (hxy : x ≤𝓛 y) (hyx : y ≤𝓛 x) : x 𝓛 y := ⟨hxy, hyx⟩

/-- Similar lemma for the J preorder. -/
@[simp] lemma JEquiv.of_le (hxy : x ≤𝓙 y) (hyx : y ≤𝓙 x) : x 𝓙 y := ⟨hxy, hyx⟩

/-- Similar lemma for the H preorder. -/
@[simp] lemma HEquiv.of_le (hxy : x ≤𝓗 y) (hyx : y ≤𝓗 x) : x 𝓗 y := ⟨hxy, hyx⟩

/-- The right preorder embeds into the J preorder. -/
@[simp] lemma RRel.to_JRel (h : x ≤𝓡 y) : x ≤𝓙 y := by
  rcases h with ⟨t, ht⟩
  refine ⟨1, t, ?_⟩
  simpa using ht

/-- The left preorder embeds into the J preorder. -/
@[simp] lemma LRel.to_JRel (h : x ≤𝓛 y) : x ≤𝓙 y := by
  rcases h with ⟨t, ht⟩
  refine ⟨t, 1, ?_⟩
  simpa using ht

/-- From an R-equivalence we can deduce the right preorder. -/
@[simp] theorem REquiv.le (h : x 𝓡 y) : x ≤𝓡 y := h.1

/-- From an L-equivalence we can deduce the left preorder. -/
@[simp] theorem LEquiv.le (h : x 𝓛 y) : x ≤𝓛 y := h.1

/-- From a J-equivalence we can deduce the J preorder. -/
@[simp] theorem JEquiv.le (h : x 𝓙 y) : x ≤𝓙 y := h.1

/-- From an H-equivalence we can deduce the H preorder. -/
@[simp] theorem HEquiv.le (h : x 𝓗 y) : x ≤𝓗 y := h.1

/-- From an R-equivalence we obtain the reversed right preorder. -/
@[simp] theorem REquiv.ge (h : x 𝓡 y) : y ≤𝓡 x := h.2

@[simp] theorem LEquiv.ge (h : x 𝓛 y) : y ≤𝓛 x := h.2
@[simp] theorem JEquiv.ge (h : x 𝓙 y) : y ≤𝓙 x := h.2
@[simp] theorem HEquiv.ge (h : x 𝓗 y) : y ≤𝓗 x := h.2

/-- R-equivalence implies J-equivalence. -/
@[simp] theorem REquiv.to_JEquiv (h : x 𝓡 y) : x 𝓙 y := by simp_all [REquiv]

/-- L-equivalence implies J-equivalence. -/
@[simp] theorem LEquiv.to_JEquiv (h : x 𝓛 y) : x 𝓙 y := by simp_all [LEquiv]

/-- H-preorder implies R-preorder -/
@[simp] lemma HRel.to_RRel (h : x ≤𝓗 y) : x ≤𝓡 y := by simp_all [HRel]

/-- H-preorder implies L-preorder -/
@[simp] lemma HRel.to_LRel (h : x ≤𝓗 y) : x ≤𝓛 y := by simp_all [HRel]

/-- H-preorder implies J-preorder -/
@[simp] lemma HRel.to_JRel (h : x ≤𝓗 y) : x ≤𝓙 y := by simp_all [HRel]

@[simp] lemma HEquiv.to_REquiv (h : x 𝓗 y) : x 𝓡 y := by simp_all [HEquiv, REquiv]

/-- H-equivalence implies L-equivalence. -/
@[simp] lemma HEquiv.to_LEquiv (h : x 𝓗 y) : x 𝓛 y := by simp_all [LEquiv]

/-! ### Basic Idempotent Properties -/

/-- Characterisation of the right preorder using an idempotent. -/
lemma RRel.idempotent_iff (h : IsIdempotentElem e) :
    x ≤𝓡 e ↔ e * x = x := by
  constructor
  · rintro ⟨t, ht⟩
    rw [← ht, ← mul_assoc]
    rw [h]
  · intro hx
    refine ⟨x, ?_⟩
    exact hx

/-- Characterisation of the left preorder using an idempotent. -/
lemma LRel.idempotent_iff (h : IsIdempotentElem e) :
    x ≤𝓛 e ↔ x * e = x := by
  constructor
  · rintro ⟨t, ht⟩
    rw [← ht, mul_assoc]
    rw [h]
  · intro hx
    refine ⟨x, ?_⟩
    exact hx

/-- ### H-Equivalence charactarization -/
theorem HEquiv.rEquiv_and_lEquiv_iff : x 𝓡 y ∧ x 𝓛 y ↔ x 𝓗 y := by
  simp [HEquiv, REquiv, LEquiv, HRel]
  aesop

/-! ### Cancelation lemmas -/

/-- `x * y` is always `≤𝓡 x` -/
@[simp] lemma RRel.mul_right_self (x y : M) : x * y ≤𝓡 x := by use y

/-- `y * x` is always `≤𝓛 x` -/
@[simp] lemma LRel.mul_left_self : y * x ≤𝓛 x := by use y

/-- `u * x * v` is always `≤𝓙 x` -/
@[simp] lemma JRel.mul_sandwich_self : u * x * v ≤𝓙 x := by use u, v

/-- if `x` is J-below `y * z`, then it is J-below `z` -/
lemma JRel.left_cancel {x y z : M} (h : x ≤𝓙 y * z) : x ≤𝓙 z := by
  obtain ⟨u, v, huv⟩ := h
  use u * y, v
  simp_all [← mul_assoc]

/-- if `x` is J-below `y * z`, then it is J-below `y` -/
lemma JRel.right_cancel {x y z : M} (h : x ≤𝓙 y * z) : x ≤𝓙 y := by
  obtain ⟨u, v, huv⟩ := h
  use u , z * v
  simp_all [← mul_assoc]

/-- if `x` is R-below `y * z`, then it is R-below `y` -/
lemma RRel.right_cancel {x y z : M} (h : x ≤𝓡 y * z) : x ≤𝓡 y := by
  rcases h with ⟨u, hu⟩
  use z * u
  simp_all [← mul_assoc]

/-- if `x` is L-below `y * z`, then it is L-below `z` -/
lemma LRel.left_cancel {x y z : M} (h : x ≤𝓛 y * z) : x ≤𝓛 z := by
  rcases h with ⟨u, huv⟩
  use u * y
  simp_all [← mul_assoc]

end BasicLemmas

/-!
### Statements about 𝓡 and 𝓛
We prove that 𝓡 and 𝓛 are compatable with left/right multiplication, respectivly.
We also prove that 𝓡 and 𝓛 (and their preorders) commute under composition.
These lemmas are essential for proving that 𝓓 is an equivalence.
-/

section REquivLEquiv

open MulOpposite

variable {M : Type*} [Monoid M] {x y z : M}

/-- `≤𝓡` is compatable with left multiplication -/
@[simp] lemma RRel.mul_left_compat (z : M) (h : x ≤𝓡 y) : z * x ≤𝓡 z * y := by
  obtain ⟨u, hu⟩ := h
  use u
  simp [mul_assoc, hu]

/-- `≤𝓛` is compatable with right multiplication -/
@[simp] lemma LRel.mul_right_compat (z : M) (h : x ≤𝓛 y) : x * z ≤𝓛 y * z := by
  obtain ⟨u, hu⟩ := h
  use u
  simp [← mul_assoc, hu]

/-- `𝓡` is compatable with left multiplication -/
@[simp] lemma REquiv.mul_left_compat (z : M) (h : x 𝓡 y) : z * x 𝓡 z * y := by simp_all [REquiv]

/-- `𝓛` is compatable with right multiplication -/
@[simp] lemma LEquiv.mul_right_compat (z : M) (h : x 𝓛 y) : x * z 𝓛 y * z := by simp_all [LEquiv]

-- Note: is this the same as the J relation?
lemma rLE_lLE_of_comm (hL : x ≤𝓛 z) (hR : z ≤𝓡 y) : ∃ u, x ≤𝓡 u ∧ u ≤𝓛 y := by
  rcases _ : hL with ⟨v, hv⟩
  rcases _ : hR with ⟨w, hw⟩
  use v * y
  simp [← hv, hR]

-- Dual to above
lemma lLE_rLE_of_comm (hR : x ≤𝓡 z) (hL : z ≤𝓛 y) : ∃ u, x ≤𝓛 u ∧ u ≤𝓡 y := by
  rcases _ : hL with ⟨v, hv⟩
  rcases _ : hR with ⟨w, hw⟩
  use y * w
  simp [← hw, hL]

/-- `≤𝓡` commutes with `≤𝓛` under composition. -/
theorem rLE_lLE_comm (x y : M) : (∃ z, x ≤𝓛 z ∧ z ≤𝓡 y) ↔ ∃ z, x ≤𝓡 z ∧ z ≤𝓛 y := by
  constructor
  · rintro ⟨u, hL, hR⟩
    apply rLE_lLE_of_comm hL hR
  · rintro ⟨u, hL, hR⟩
    apply lLE_rLE_of_comm hL hR

/-- `𝓡` commutes with `𝓛` under composition. -/
lemma rEquiv_lEquiv_of_comm (hL : x 𝓛 z) (hR : z 𝓡 y) : ∃ u, x 𝓡 u ∧ u 𝓛 y := by
  rcases _ : hL with ⟨hL₁, hL₂⟩ -- the `_ : hL` syntax preserves the original hL
  rcases _ : hR with ⟨hR₁, hR₂⟩
  obtain ⟨t, ht⟩ := hL₁
  use t * y
  subst x
  constructor
  · simp [hR] -- proof `t * z 𝓡 t * y`
  · simp [LEquiv] --  proof `t * y 𝓛 y`
    obtain ⟨w, hw⟩ := hR₂
    rw [← hw, ← mul_assoc]
    simp [hL₂]

-- Dual of above
lemma lEquiv_rEquiv_of_comm (hR : x 𝓡 z) (hL : z 𝓛 y) : ∃ u, x 𝓛 u ∧ u 𝓡 y := by
  rcases _ : hL with ⟨hL₁, hL₂⟩
  rcases _ : hR with ⟨hR₁, hR₂⟩
  obtain ⟨t, ht⟩ := hR₁
  use y * t
  subst x
  constructor
  · simp [hL]
  · simp [REquiv]
    obtain ⟨w, hw⟩ := hL₂
    rw [← hw, mul_assoc]
    simp [hR₂]

/-- **Green's Commutativity**: R and L relations commute under composition -/
theorem rEquiv_lEquiv_comm: (∃ z, x 𝓛 z ∧ z 𝓡 y) ↔ ∃ z, x 𝓡 z ∧ z 𝓛 y := by
  constructor
  · rintro ⟨z, hL, hR⟩
    apply rEquiv_lEquiv_of_comm hL hR
  · rintro ⟨z, hL, hR⟩
    apply lEquiv_rEquiv_of_comm hL hR

end REquivLEquiv

/-! ### 𝓓 Relation -/

section DEquiv

variable {M : Type*} [Monoid M]

/-- The **D equivalence**: `DEquiv x y` holds if
there exists a `z` such that  `x 𝓡 z` and `z 𝓛 y`. -/
def DEquiv (x y : M) : Prop := ∃ z, x 𝓡 z ∧ z 𝓛 y

notation:50 x " 𝓓 " y:50 => DEquiv x y

/-- Alternate Def of `𝓓`, equivalent by 𝓡-𝓛 communitivity -/
theorem DEquiv.comm {x y : M} : (∃ z, x 𝓛 z ∧ z 𝓡 y) ↔ x 𝓓 y := by
  simp [DEquiv, rEquiv_lEquiv_comm]

open MulOpposite in

@[simp] lemma DEquiv.refl (x : M) : x 𝓓 x := by use x; simp_all

variable {x y z : M}

@[symm] lemma DEquiv.symm (h : x 𝓓 y) : y 𝓓 x := by
  simp_all [DEquiv]
  rw [← rEquiv_lEquiv_comm]
  obtain ⟨z, ⟨hR, hL⟩⟩ := h
  use z
  exact ⟨hL.symm, hR.symm⟩

/-- The 𝓓-relation is preserved by 𝓛-equivalent elements on the right.
If `a 𝓓 b` and `b 𝓛 c`, then `a 𝓓 c`. -/
lemma DEquiv.closed_under_lEquiv (hD : x 𝓓 y) (hL : y 𝓛 z) : x 𝓓 z := by
  simp_all [DEquiv]
  obtain ⟨u, ⟨hR, hL₂⟩⟩ := hD
  use u
  simp_all
  apply LEquiv.trans hL₂ hL

-- Dual to above
lemma DEquiv.closed_under_rEquiv (hD : x 𝓓 y) (hR : y 𝓡 z) : x 𝓓 z := by
  have hD₁ := hD.symm
  symm
  simp_all [DEquiv]
  obtain ⟨u, ⟨hR₂, hL₂⟩⟩ := hD₁
  use u
  simp_all
  apply REquiv.trans hR.symm hR₂

/-- The 𝓓-relation is transitive. This is proved using closure under 𝓡 and 𝓛. -/
lemma DEquiv.trans (h₁ : x 𝓓 y) (h₂ : y 𝓓 z) : x 𝓓 z := by
  obtain ⟨u, ⟨hy1, hy2⟩⟩ := h₂
  have hd1 : x 𝓓 u := DEquiv.closed_under_rEquiv h₁ hy1
  apply DEquiv.closed_under_lEquiv hd1 hy2

/-- The 𝓓-relation is an equivalence relation on `M`. -/
instance DEquiv.isEquiv: Equivalence (fun a b : M => a 𝓓 b) where
  refl := DEquiv.refl
  symm := DEquiv.symm
  trans := DEquiv.trans

/-! ### Conversion Lemmas for DEquiv -/

@[simp] lemma REquiv.to_dEquiv (h : x 𝓡 y) : x 𝓓 y := by use y; simp_all
@[simp] lemma LEquiv.to_dEquiv (h : x 𝓛 y) : x 𝓓 y := by use x; simp_all

/-- Every 𝓓-related pair is 𝓙-related.
Note that the reverse implication only holds in finite semigroups.
This will be proven later. -/
@[simp] theorem DEquiv.to_JEquiv (h : x 𝓓 y): x 𝓙 y := by
  simp_all [DEquiv, JEquiv]
  rcases h with ⟨z, ⟨⟨t, hR₁⟩, ⟨u, hR₂⟩⟩ , ⟨⟨v, hL₁⟩, ⟨w, hL₂⟩⟩⟩
  constructor
  · use v, t
    rw [← hR₁, ← hL₁]
  · use w, u
    rw [← hL₂, ← hR₂, ← mul_assoc]

end DEquiv

/-! ### Equivalence classes as Sets -/

section EquivalenceClasses

variable {M : Type*} [Monoid M] (x : M)

@[simp] def REquiv.set : Set M := {y | y 𝓡 x}
@[simp] def LEquiv.set : Set M := {y | y 𝓛 x}
@[simp] def JEquiv.set : Set M := {y | y 𝓙 x}
@[simp] def HEquiv.set : Set M := {y | y 𝓗 x}
@[simp] def DEquiv.set : Set M := {y | y 𝓓 x}

notation "⟦" x "⟧𝓡" => REquiv.set x
notation "⟦" x "⟧𝓛" => LEquiv.set x
notation "⟦" x "⟧𝓙" => JEquiv.set x
notation "⟦" x "⟧𝓗" => HEquiv.set x
notation "⟦" x "⟧𝓓" => DEquiv.set x
